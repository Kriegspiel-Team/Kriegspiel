\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}
\usepackage[french]{babel}  
\usepackage{graphicx}
\usepackage{url}
\usepackage{ulem}
\usepackage[hidelinks,breaklinks]{hyperref}
\usepackage{breakurl}

\input{vc.tex}
                            
\begin{document} 
	\title{Mémoire}             
	\author{
		David Cheminade
		\and
		Guillaume Desbieys
		\and
		Quentin Michaud
		\and
		Hubert Mondon
	}                       
	\date{}
	\maketitle{}                          

	\clearpage
	
	\section*{Resume}
	
	\paragraph{}
	Notre projet consiste à réaliser un moteur de règles pour le jeu de la guerre de Debord et à mettre en place un 
	évaluateur statique permettant de calculer les informations brutes nécessaires à une éventuelle future prise de décision.
	L'utilisateur peut fournir une situation de jeu sous forme de fichier ASCII et notre programme se chargera d'afficher 
	cette situation en y appliquant les diverses règles pour les calculs des zones d'influence et des potentiels offensifs et défensifs.
	L'objectif de ce projet est donc de créer une base solide qui permettra par la suite d'implémenter un moteur 
	décisionnel qui se base sur nos données statiques pour ses divers calculs.
	
	\let\thefootnote\relax
	\footnotetext{Revision~\GITAbrHash, \GITAuthorDate.}  

	\clearpage
	
	\tableofcontents
	
	\clearpage

	%\section{Introduction}

	\chapter{Introduction}
	\markboth{\MakeUppercase{Introduction}}{}
	

		\paragraph{}
		Le jeu de la guerre a été inventé par Guy Debord en 1965 dans le but de faire apparaître les différentes stratégies de la guerre sur un jeu de plateau. 
		Les règles y sont donc nombreuses et le jeu est assez complexe ce qui permet la mise en application de stratégies très variées.
		En raison de ces nombreuses règles et de sa complexité notoire, il n'existe à ce jour aucun joueur contrôlé par ordinateur permettant de jouer à ce jeu.
		
		\paragraph{}
		Réaliser un joueur automatique pour ce jeu est une tâche conséquente nécessitant un travail important en amont pour préparer la prise de décision.
		Dans le cadre de ces PDP, c'est ce travail de préparation à la prise de décision que nous efectuerons, plutôt que la prise de décision elle même.
		Notre projet consiste ainsi à pouvoir évaluer de façon statique une situation de jeu en prenant en compte toutes les règles qui s'appliquent via le moteur de règles.
		En d'autres termes, nous devrons extraire des informations utiles d'une situation spécifique en prenant en compte les règles du jeu dans le but futur de pouvoir prendre une décision acceptable même si non optimisée.
		
		\paragraph{}
		Nous expliquerons dans ce rapport quelle a été notre approche pour venir à bout de ce projet et détaillerons par ailleurs notre architecture et nos
		choix d'implémentation. Nous présenterons également le rendu obtenu en détaillant le travail qui a été effectué et les options manquantes, puis
		nous nous pencherons sur les tests qui ont été faits pour vérifier le bon fonctionnement de notre projet.
		
		\clearpage

	%\section{Règles du jeu}  

	\chapter{Règles du jeu}
	\markboth{\MakeUppercase{Règles du jeu}}{}

		\section{Apprendre à jouer}
		
		Le jeu de la guerre est un jeu de type tour par tour se jouant sur un plateau de 500 cases. (25 * 20)
		Le but de celui-ci est de détruire l'armée adverse en prenant ses arsenaux ou en détruisant toutes les unités. (Voir les conditions de victoire)
		Vous disposerez de plusieurs types d'unités ayant des caractéristiques différentes (attaque, défense, portée, vitesse) que vous devrez déplacer 
		en prenant en compte les lignes de communication.
		En effet, si vos unités sortent des lignes de communication, celles-ci ne pourront alors plus bouger et pourront être détruites facilement.
		Pour accéder aux règles complètes, (caractéristiques des unités, explications plus détaillées) rendez-vous sur [Intégrer RSG biblio]
		
		\section{Règles à implémenter}
		Pour toute situation de jeu donnée, voici la liste des règles qui devront être prises en compte par notre moteur.

		\paragraph{Conditions de victoire}
		\begin{enumerate}
		\item Détruire tous les arsenaux adverses.
		\item Détruire toutes les unités de combat adverses.
		\item Détruire les relais et couper toutes les communications des unités adverses.
		\end{enumerate}
		
		\paragraph{Lignes de communications}
		\begin{enumerate}
		\item Les arsenaux propagent des lignes de communication.
		\item Un arsenal détruit ne propage plus de lignes de communication.
		\item Un relais transmet les lignes de communications si il se trouve lui même sur une ligne de communication alliée.
		\item Une unité est connectée si elle se trouve sur une ligne de communication.
		\item Une unité est connectée si elle se trouve à proximité d'une unité alliée connectée.
		\item Une unité déconnectée ne peut pas bouger.
		\item L'attaque et la défense d'une unité déconnectée est égale à 0.
		\end{enumerate}
		
		\paragraph{Calcul des potentiels}
		\begin{enumerate}
		\item Chaque type d'unité movible a une valeur d'attaque/défense/portée qui lui est spécifique. (voir règles précises)
		\item L'attaque subie par une unité se calcule en additionnant toutes les attaques des unités adverses à portée.
		\item Le potentiel défensif d'une unité se calcule en additionnant toutes les défenses des unités alliées à portée.
		\item Même si une unité est à portée d'une autre, sa valeur d'attaque/défense n'est pas ajoutée lors des calculs si un obstacle (unité adverse ou montagne) se trouve entre les deux.
		\end{enumerate}
		
		\paragraph{Bonus défensifs et offensifs}
		\begin{enumerate}
		\item Les cols octroient un bonus défensif de ... aux ...
		\item Les forteresses octroient un bonus défensif de ... aux ...
		\item Si plusieurs cavaliers sont alignés face à une unité adverse, ils bénéficient d'un bonus d'attaque de 3 et peuvent tous attaquer même si ils sont hors de portée.
		\end{enumerate}
		
		\paragraph{Autres règles}
		\begin{enumerate}
		\item Un cavalier ne peut pas charger dans une forteresse.
		\item Une unité peut être détruite si l'attaque subie par celle-ci est supérieur à son potentiel défensif.
		\item Une unité doit battre en retraite si l'attaque subie par celle-ci est égale à son potentiel défensif.
		\item Une unité ne peut pas traverser les montagnes ou les autres unités.
		\end{enumerate}
		\clearpage

	%\section{Analyse de l'existant}  

	\chapter{Analyse de l'existant}
	\markboth{\MakeUppercase{Analyse de l'existant}}{} 

		\paragraph{}
		Le jeu de la guerre appelé aussi "Kriegspiel" est parfois considéré comme une évolution du jeu d'échecs.
		Le modèle qui nous intéresse et sur lequel nous nous baserons dans le cadre de ce projet est celui de Guy Debord qui l'a breveté en 1965.
		Une application permettant de jouer au jeu a été développée par Radical Software Group (RSG), un collectif de développeurs et d'artistes 
		créé en 2000 dont le but est de travailler sur des programmes expérimentaux.
		
		\paragraph{}
		Cette version du jeu a été développée en Java en utilisant les librairies suivantes :
		
		\begin{itemize}
			\item Java Monkey Engine pour le moteur de jeu
			\item Project Darkstar pour la partie réseau
			\item La modélisation des objets graphiques a été faite via Blender
		\end{itemize}

		\paragraph{}
		L'interface du jeu a été travaillée de sorte à montrer aux joueurs les déplacements possibles pour chaque pièce. De plus les axes de 
		communication sont affichés avec des pointillés pour faciliter la vision du jeu.
		
		\paragraph{}
		L'application propose un mode "practice" permettant de jouer seul afin de se familiariser avec les règles du jeu ainsi que l'interface.
		Un second mode permet aux joueurs de s'affronter en ligne afin d'expérimenter de nouvelles stratégies.
		
		\paragraph{}
		Les développeurs du site RSG ont écarté l'idée d'y implémenter un joueur automatique puisque le but de leur projet était de 
		pouvoir y apprendre la stratégie face a un adversaire réel.
		
		\paragraph{}
		Malgré les documents décrivant des stratégies de jeu, il n'existe donc pas actuellement de joueur automatique pour ce jeu.
		
		\clearpage

	%\section{Etude des besoins}   

	\chapter{Etude des besoins}
	\markboth{\MakeUppercase{Etude des besoins}}{}

		\section{Réalisation d'un moteur de règles}

			Notre moteur de règles est un système qui doit posséder l'ensemble des règles du jeu afin de pouvoir les appliquer à une situation de jeu.

			\begin{enumerate}

				\item \textbf{Transcrire les règles sous forme logique et les incorporer au moteur.} 
				\\[0.7\baselineskip]
				Priorité : Forte 
				\\[0.7\baselineskip]
				Description : Nous devons transcrire les règles du jeu de façon à ce que le système puisse les comprendre c'est à dire que ces 
				règles doivent être codées à l'aide de conditions logiques. Etant donné une situation de jeu, le moteur de règles doit pouvoir 
				propager les lignes de communications, octroyer les bonus défensifs pour les unités sur les forts, etc.
				\\[0.7\baselineskip]
				Tests : Pour tester notre moteur de règles, nous pouvons utiliser la partie commentée du livre de Guy Debord. Nous pouvons 
				vérifier que les coups qui sont effectués dans cette partie soient bien affichés parmis les coups valides proposés par notre 
				moteur de règles. Cela ne nous garantira pas un fonctionnement parfait du moteur de règles néanmoins ce test pourrait nous 
				aider à trouver des dysfonctionnements. 
				\\[0.7\baselineskip]
				
			\end{enumerate}

		\section{Interface graphique}

			\begin{enumerate}

				\item \textbf{Créer une interface de jeu minimale} 
				\\[0.7\baselineskip]
				Priorité : Forte 
				\\[0.7\baselineskip]
				Description : Nous devons créer une interface permettant de représenter de manière très minimaliste le plateau de jeu (position des unités, 
				montagnes, lignes de communication). 
				\\[0.7\baselineskip]
				Tests : On vérifiera l'exactitude du plateau et la cohérence des informations affichées par rapport au modèle interne. 
				\\[0.7\baselineskip]

				\item \textbf{Représentation graphique de la situation} 
				\\[0.7\baselineskip]
				Priorité : Forte 
				\\[0.7\baselineskip]
				Description : Cette interface devra également permettre de visualiser l'analyse effectuée par l'évaluateur de situation. 
				\\[0.7\baselineskip]
				Tests : Bien que cette fonctionnalité sera en elle-même un test de l'évaluateur, son fonctionnement pourra être vérifié par exemple en 
				le faisant cohabiter avec des affichages en console. 
				\\[0.7\baselineskip]

				
			\end{enumerate}

		\section{Représentation d'une situation de jeu}

			\begin{enumerate}

				\item \textbf{Créer un système basique de chargement d'une situation de jeu} 
				\\[0.7\baselineskip]
				Priorité : Forte 
				\\[0.7\baselineskip]
				Description : Afin de pouvoir tester les algorithmes du moteur de règles et de l'évaluateur de position plus efficacement, nous aurons besoin 
				d'un système permettant de charger des situations de jeu directement depuis un fichier texte, par exemple en ASCII ou autre format simple. 
				Ce fichier devra simplement contenir les coordonnées de tout les pions sur le plateau de jeu. 
				\\[0.7\baselineskip]
				Tests : Il s'agira simplement de comparer les données du fichier de chargement avec celles du plateau de jeu. 
				\\[0.7\baselineskip]
				
			\end{enumerate}

		\section{Evaluation statique des positions}

			\begin{enumerate}

				\item \textbf{Déterminer la zone d'influence des unités} 
				\\[0.7\baselineskip]
				Priorité : Moyenne 
				\\[0.7\baselineskip]
				Description : Pour chaque unité, il sera nécessaire de déterminer en fonction des règles incorporées au moteur sa zone d'influence exacte, 
				c'est à dire toutes les cases sur lesquelles l'unité en question pourra se déplacer ou attaquer au tour suivant. Cela permettra de déterminer 
				l'ensemble des coups jouables pour chaque unité. 
				\\[0.7\baselineskip]
				Tests : Placer une cavalerie près d'une ligne de montagnes en présence d'autres unités et vérifier qu'il peut se déplacer normalement sans traverser 
				les différents obstacles. 
				\\[0.7\baselineskip]

				\item \textbf{Calculer les potentiels offensifs et défensifs des unités} 
				\\[0.7\baselineskip]
				Priorité : Moyenne 
				\\[0.7\baselineskip]
				Description : Chaque unité possède d'après les règles ses propres caractéristiques (attaque, défense...) mais le potentiel offensif et défensif 
				d'une unité peut être modifié si d'autres sont en présence directe. Il sera donc nécessaire de calculer ces potentiels pour chaque unité pour en déduire 
				par la suite les zones fortes ou faibles. 
				\\[0.7\baselineskip]
				Tests : Prévoir différentes situations radicalement différentes et noter les potentiels calculés par le jeu disponible sur r-s-g.org. Vérifier ensuite 
				que nous avons les mêmes valeurs pour toutes les situations testées. 
				\\[0.7\baselineskip]

				\item \textbf{Exploiter les données pour déterminer les coefficients de dangeurosité d'une zone} 
				\\[0.7\baselineskip]
				Priorité : Moyenne 
				\\[0.7\baselineskip]
				Description : Après avoir déterminé les zones d'influence et les potentiels offensifs et défensifs des unités, nous pourrons exploiter ces données pour 
				créer un plateau secondaire coefficienté sur lequel seront représentées les zones à éviter ou non. Les coefficients seront calculés pour chaque case en 
				fonction de la proximité des unités et de leur valeur offensive. Dans un premier temps, une seule armée sera prise en compte dans les calculs. Nous pourrons 
				par la suite prendre en compte la seconde armée et adapter les coefficients en fonction de celle-ci. 
				\\[0.7\baselineskip]
				Tests : Prévoir plusieurs situations différentes et déterminer nous-même les zones dangereuses ou interessantes, puis comparer 
				avec le résultat de notre algorithme. 
				\\[0.7\baselineskip]
				
			\end{enumerate}

		\section{Evaluation dynamique des positions}

			\begin{enumerate}

				\item \textbf{Déterminer les coefficients de dangeurosité d'une zone sur plusieurs tours} 
				\\[0.7\baselineskip]
				Priorité : Faible 
				\\[0.7\baselineskip]
				Description : De la même manière que l'évaluateur statique déterminera des coefficients pour chaque zone, nous devrons par la suite en reprenant des 
				algorithmes très similaires, redéterminer des coefficients de dangeurosité sur chaque case, en prenant en compte cette fois ci, plusieurs tours de jeu. 
				Le but sera d'obtenir un plateau de jeu coefficienté indiquant les zones avantageuses et désavantageuses pour chaque armée. 
				\\[0.7\baselineskip]
				Tests : Dans un premier temps, en prenant des situations précises, il s'agira de déterminer sur papier (en appliquant les mêmes algorithmes que ceux 
				implémentés dans l'évaluateur) les cases du plateau étant dangereuses pour une armée et avantageuses pour l'autre, et d'en comparer les résultats avec 
				les coefficients obtenus par l'évaluateur. 
				\\[0.7\baselineskip]
				
			\end{enumerate}

		\section{Moteur tactique}

			\begin{enumerate}

				\item \textbf{Appliquer une stratégie en fonction des données résultantes de l'évaluation de positions} 
				\\[0.7\baselineskip]
				Priorité : Faible 
				\\[0.7\baselineskip]
				Description : Ce dernier besoin consistera à essayer de mettre en place un système de règles logiques permettant la décision de coups en exploitant les 
				calculs de l'évaluateur dynamique de positions. 
				
			\end{enumerate}
		
		\clearpage

	%\section{Architecture du projet}    

	\chapter{Architecture du projet}
	\markboth{\MakeUppercase{Architecture du projet}}{}

		\section{Schéma UML}

			\includegraphics[scale=0.4]{images/diag_classes.eps}

			\clearpage

		\section{Description des classes}

			\subsection{Board}
			
				\paragraph{Définition :}
				Le Board est une matrice de taille fixe représentant une situation de jeu.
				\paragraph{Interaction :}
				Certaines cases du Board contiendront des objets de type Entity.
				

			\subsection{EntityLoader}

				\paragraph{Définition :}
				Classe permettant de charger une partie à partir d'un fichier. Elle transcrira les informations brute du 
				fichier en un Board contenant des Entity.
				\paragraph{Interaction :}
				L'EntityLoader interagira avec le Board puisque sa fonction consiste à modifier celui-ci.

			\subsection{Entity}

				\paragraph{Définition :}
				Les Entity représentent les éléments de jeu (les unités ainsi que les batiments et obstacles).
				\paragraph{Interaction :}
				Toutes les Entity seront disposées à l'intérieur d'une matrice dans la classe Board.

			\subsection{MovableEntity}

				\paragraph{Définition :}
				Les MovableEntity sont les unités movibles telles que les infanteries, les cavaliers, les canons ou toute autre unité 
				qu'il est possible de déplacer.
				\paragraph{Interaction :}
				Les MovableEntity seront disposées à l'intérieur d'une matrice dans la classe Plateau.

			\subsection{UnmovableEntity}

				\paragraph{Définition :}
				Les UnmovableEntity sont des entités présentes sur le plateau mais que les règles ne permettent pas de déplacer. 
				Les forts, les arsenaux, les montagnes ou les cols sont par exemple des UnmovableEntity.
				\paragraph{Interaction :}
				Les UnmovableEntity seront disposées à l'intérieur d'une matrice dans la classe Board. 
				Certaines UnmovableEntity pourront par ailleurs contenir des MovableEntity. (exemple : les forts)

			\subsection{Engine}

				!!!!!!!!!!!! A COMPLETER !!!!!!!!!!!!
				\paragraph{Définition :}
				Cette classe représente le moteur de règles et doit faire l'intermediaire entre les faits (la situation de jeu actuelle) 
				et les règles qui sont implémentées dans un fichier ".drl".
				\paragraph{Interaction :}
				L'Engine intéragira avec .....

			\subsection{Rule}

				!!!!!!!!!!!! A COMPLETER !!!!!!!!!!!!
				\paragraph{Définition :}
				Une règle sera une expression logique associée à un fait. Elles ne seront en fait pas codées sous forme de classe mais 
				sous forme de fichier en ".drl".
				\paragraph{Interaction :}
				Les règles seront envoyées à l'Engine qui devra se charger de les appliquer.

			\subsection{InfluenceArea}

				\paragraph{Définition :}
				Cette classe permettra de calculer les zones d'influence des unités, c'est à dire l'ensemble des cases sur lesquelles 
				chaque unité peut agir.
				\paragraph{Interaction :}
				La classe InfluenceArea aura besoin d'un objet de type Board pour faire ses calculs et stockera les résultats dans 
				les entités elles-mêmes.

			\subsection{Potential}

				\paragraph{Définition :}
				Cette classe permettra de calculer les potentiels offensifs et défensifs des unités en fonction de leur configuration spatiale.
				\paragraph{Interaction :}
				La classe Potential aura besoin d'un objet de type Board pour faire ses calculs et stockera les résultats dans les 
				entités elles-mêmes.

			\subsection{DangerousnessMatrix}

				!!!!!!!!!!!! A COMPLETER - Ne va même pas exister ? !!!!!!!!!!!!
				\paragraph{Définition :}
				Cette classe permettra de stocker la matrice de dangerosité représentant les endroit avantageux ou à éviter.
				\paragraph{Interaction :}
				La classe DangerousnessMatrix ...

			\subsection{StaticEvaluator}

				!!!!!!!!!!!! A COMPLETER - Ne va même pas exister ? !!!!!!!!!!!!
				\paragraph{Définition :}
				AREFAIRE : Le StaticEvaluator est la classe permettant de calculer et stocker l'ensemble des résultats de nos algorithme 
				d'évaluation statique du jeu.
				\paragraph{Interaction :}
				AREFAIRE : Le StaticEvaluator agit directement sur InfluenceArea, Potential et DangerousnessMatrix puisqu'il se charge 
				de les mettre à jour. Le moteur décisionnel aura quant à lui accès à l'évaluateur pour pouvoir prendre des décisions en fonction 
				des résultats trouvés par l'évaluateur.

			\subsection{DecisionnalEngine}

				\paragraph{Définition :}
				Le DecisionnalEngine se charge de choisir le coup à jouer en fonction d'une situation de jeu donnée et des résultats 
				du StaticEvaluator.
				\paragraph{Interaction :}
				Le DecisionnalEngine interagira avec le Board pour connaître la situation de jeu et les Entity pour connaître les 
				différentes données calculées par le StaticEvaluator.

			\subsection{BoardDisplayer}

				\paragraph{Définition :}
				Ceci est la classe principale de l'interface graphique. Elle se charge d'afficher les données (Entités et valeurs calculées)
				et contient le MenuDisplayer.
				\paragraph{Interaction :}
				Le BoardDisplayer récupère les données contenues dans le Board afin de pouvoir les afficher, il récupère également des données qui sont calculées
				par le moteur de règles pour chaque entité et stockées dans les entités.

			\subsection{MenuDisplayer}

				\paragraph{Définition :}
				C'est la deuxième classe formant l'interface graphique. Elle contient les boutons et checkboxes qui permettent
				de régler les paramètres d'affichage. Elle permet également de déclencher le chargement d'un fichier.
				\paragraph{Interaction :}
				Le MenuDisplayer modifie les paramètres d'affichage contenus dans le BoardDisplayer lorsque l'utilisateur clique
				sur les éléments du menu ou utilise des raccourcis clavier.


		
		
	%\section{Présentation du rendu}

	\chapter{Présentation du rendu}
	\markboth{\MakeUppercase{Présentation du rendu}}{}     

		\section{ Aspect général}

			\includegraphics[scale=0.4]{images/screen1.eps}
			\paragraph{Le plateau :}
			L'affichage du plateau prend la majorité de la fenêtre.
			Les entités sont représentées par des lettres dans des cases de la couleur de leur équipe.
			Les \^{} sur fond gris sont les montagnes.
			Les cases possédant une bordure pointillée noire sont les entités qui peuvent contenir une autre entité	(les arsenaux et les forts).
			Les cases vertes représentent les possibilités de mouvement	de l'entité sélectionnée (ici le SwiftCanon bleu). 
			Notons que l'unité ne peut pas se déplacer sur une case déja occupée.
			Lorsqu'une entité risque d'être détruite au prochain tour, son symbole est entouré de ( ).
			Lorsqu'elle est forcée de se retirer au prochain tour, son symbole est entouré de [ ].
		
			\paragraph{Le menu :}
		
			Le menu contient différents éléments :
			- Le bouton de chargement en haut permet de charger une situation depuis un fichier?
			- Les checkboxes permettent d'activer ou de désactiver les communications
			- Les grands boutons permettent de changer le mode d'affichage

		\section{ Les modes d'affichage}

			\subsection{ Mode unités}
			\includegraphics[scale=0.4]{images/screen1.eps}
			C'est le mode d'affichage principal, les symboles des unités sont affichés.

			\clearpage

			\subsection{ Modes attaque/défense}
			\includegraphics[scale=0.4]{images/screen2.eps}
			Dans le mode attaque, le total d'attaque potentiel est affiché sur chaque unité.
			Dans le mode défense, le total de défense de l'unité est affiché.
		
			\clearpage	

			\subsection{ Mode prédominance}
			\includegraphics[scale=0.4]{images/screen3.eps}
			Dans le mode prédominance, la matrice de prédominance du joueur choisi est affichée.

			\clearpage

		\section{ Autres fonctionnalités }

			\subsection{ Lignes de communication }
			\includegraphics[scale=0.4]{images/screen4.eps}
			Les lignes de communication sont représentées par des cercles de la couleur de l'équipe.
			Les unités déconnectées ont une teinte plus claire que les unités connectées.
			On peut remarquer que les unités adverses bloquent les communications et que les relais alliés les propagent.
			\clearpage
		
	%\section{Choix algorithmiques} 

	\chapter{Choix algorithmiques}
	\markboth{\MakeUppercase{Choix algorithmiques}}{}  

		\section{A. Calcul des zones d'influence}
		
			\paragraph{}
			Le calcul des zones d'influence est découpé en 2 fonctions distinctes :
			
			\paragraph{1. runInfluenceArea : }
			Cette fonction se charge de récupérer toutes les unités mobiles d'un Board qui lui est passé en paramètre.
			Elle lance ensuite computeInfluenceAreas sur chacune de ces unités.
			[Code de la fonction]
			
			\paragraph{2. computeInfluenceAreas : }
			Cette fonction récursive calcule la zone d'influence pour une unité donnée à partir d'une case et d'une variable speedLeft. 
			(qui correspond à la capacité de déplacement restante de l'unité)
			Si la capacité de déplacement restante d'une unité n'est pas nulle (speedLeft\textgreater0), alors on parcoure toutes les cases 
			qui sont autour de la case passée en paramètre. 
			Au premier appel de cette fonction, cette case sera la case sur laquelle se situe l'entité pour laquelle on calcule la zone d'influence.
			Si une ou plusieurs de ces cases sont libres, on modifie l'entité en ajoutant ces cases dans la liste de ses mouvements possibles, 
			puis on rappelle computeInfluenceAreas sur celles-ci en décrémentant le speedLeft de 1.
			Ainsi La zone d'influence ne pourra pas s'étendre à travers les unités ou les montagnes.
			[Code de la fonction]
		
		\section{B. Calcul des communications}
		
			La propagation des communications est découpés en 2 fonctions distinctes :
			
			\paragraph{1. computeArsenalsCommunications : }
			Cette fonction se charge de calculer les communications pour l'ensemble des arsenaux se trouvant sur le Board.
			Elle récupère donc l'ensemble des arsenaux sur le plateau et appelle la fonction computeCommunications sur chacun d'entre eux.
			
			\paragraph{2. computeCommunications : }
			Chaque fois qu'une entité propageant des communications est trouvée, (donc arsenal ou relais en communication) cette fonction est appelée
			avec les coordonnées x et y de l'unité en question.
			N'importe quelle unité propageant les lignes de communication le fait dans 8 directions. (nord, nord-est, est, etc)
			Nous parcourons donc ces 8 lignes une à une, case par case et ajoutons toutes les cases libre à la liste des communications jusqu'à
			la rencontre d'un obstacle. (Montagne, unités adverse ou bien fin du plateau)
			Par la suite, si Drools détecte qu'un nouveau relais est connecté suite à la propagation de lignes de communications, computeCommunications
			sera ré-appelée sur ces relais nouvellement connectés.
		
		\section{C. Calcul des potentiels}
		
			\paragraph{}
			Le calcul des potentiels est découpé en 3 fonctions distinctes :
			
			\paragraph{1. computePotentials : }
			Cette fonction se charge de remplir la matrice des potentiels pour chaque équipe.
			Elle parcoure le board dans son intégralité (une fois pour chaque équipe), appelle sur chaque case les fonctions computeAttack et 
			computeDefence, puis enregistre les valeurs dans une matrice.
			
			\paragraph{2. computeDefence : }
			Cette fonction calcule la défense pour une case et une équipe donnée.
			Après avoir initialisé la defense à 0, nous parcourons une à une les lignes pouvant avoir un impact sur la défense d'une unité.
			Il y a donc 8 lignes distinctes. (ligne au nord de l'unité, ligne au nord-est, ligne à l'est, etc)
			Pour chaque ligne, nous parcourons ensuite chaque case de la plus proche à la plus lointaine.
			Si une de ces cases contient une unité alliée à portée, nous ajoutons la défense de cette unité à la défense de cette case, 
			sauf dans le cas ou nous avons rencontré un obstacle.
			Pour savoir si nous avons rencontré un obstacle, nous mettons simplement le booléen obstacle à true si une des cases de la 
			ligne contient une unité ennemie ou une montagne.
			
			\paragraph{3. computeAttack : }
			Cette fonction calcule l'attaque subie pour une case et une équipe donnée.
			Elle a un fonctionnement très similaire à computeDefence, excepté que nous avons du ici prendre en compte la charge pour les cavaleries. 
			(qui est d'ailleurs annulée dés lors qu'un cavalier se situe sur un fort)
			Pour prendre en compte ceci, nous avons rajouté un booléen charge qui est passé à false quand on rencontre un obstacle 
			ou un fort sur la ligne analysée.
			La valeur d'attaque varie suivant si le cavalier est en charge ou non donc nous ajoutons attackCharge si le booléen charge est 
			à true ou attack si le booléen est à false.
			
		\clearpage
		
	%\section{Tests réalisés}    

	\chapter{Tests réalisés}
	\markboth{\MakeUppercase{Tests réalisés}}{}

		\section{Tests de non-régression}
		
		Afin d'éviter la régression lors de l'évolution du projet nous avons utilisé la librairie JUnit pour faciliter la gestion des tests. 
		Nous avons généré des classes de tests afin de valider le bon fonctionnement de l'ensemble des méthodes pour une classe donnée.
		Par soucis de temps, nous n'avons pas pu réaliser les tests pour chaque classes du projet, nous avons donc décidé de ne faire ces tests que sur les classes les plus « critiques ».
		Parmis ces classes dites « critiques » nous avons la classe EntityLoader qui est garante du bon placement des unités ainsi que la classe Board qui contient les données du jeu
		ainsi que certains algorithmes principaux.
		
		\section{Tests unitaires}
		
		Ceci est du texte
		
		\section{Tests fonctionnels}
		
		Ceci est du texte
		
		\clearpage
		
	\chapter{Bilan}
	\markboth{\MakeUppercase{Bilan}}{}	

		\section{Difficultés rencontrées}   


			\subsection{ A. gna gna}
			
			Ceci est du texte
			
			\subsection{ B. gna gna}
			
			Ceci est du texte
			
			\subsection{ C. gna gna}
			
			Ceci est du texte
			
			\clearpage

		\section{Conclusion}
		
			Importer la biblio à la fin car chiant à générer sous latex.
			
			\clearpage

	%\section{Elements bibliographiques}

	\chapter{Elements bibliographiques}
	\markboth{\MakeUppercase{Elements bibliographiques}}{}	
	
	\begin{itemize}
	
	\item Le livre~\cite{ref1} présente une partie commentée du jeu de la guerre accompagnée de schémas illustrés. 
	De plus on peut trouver les règles officielles proposées par Guy Debord à partir de la page 131.
	\\[0.7\baselineskip]
	
	\item Le livre Artificial Intelligence for Games~\cite{ref2} aborde dans son 5\up{ème} chapitre la prise de décision d'un point de vue technique. 
	On y trouve le principe de fonctionnement et un exemple d'implémentation de diverses structures de données (arbre de décision, machine à état, 
	arbre de comportement, moteur de règles).
	\\[0.7\baselineskip]

	\item Ce site~\cite{ref3} regroupe l'ensemble des règles du jeu de la guerre et propose une version jouable. Cette version jouable permettra 
	de bien comprendre les règles du jeu et de vérifier que notre jeu a bien le même comportement.
	\\[0.7\baselineskip]

	\item Cet ouvrage~\cite{ref4} concernant l'intelligence artificielle propose une grande variété d'idées sur les programmes heuristiques. 
	Il explique comment gérer la prise de décision acceptable mais non optimale, dans les cas où la prise de décision optimale nécessite trop de ressources.
	\\[0.7\baselineskip]
	
	\item Cette page~\cite{ref5} propose des explications d'algorithmes utilisables dans le cas de jeu se jouant à deux, tour par tour et 
	pour lequel chaque joueur connait la position de son adversaire.
	\\[0.7\baselineskip]
	
	\item Cette page~\cite{ref6} propose un tutoriel très complet sur l'utilisation de Jboss drools, outil qui nous permettra de concevoir notre moteur de règles.
	\\[0.7\baselineskip]
	
	\item Ce tutoriel~\cite{ref7} sur la bibliothèque Swing pourra nous servir pour la conception de l'interface graphique. Cette bibliothèque 
	permettra par exemple d'afficher le plateau et d'interagir avec au besoin.
	\\[0.7\baselineskip]
	
	\end{itemize}
		
	\bibliographystyle{unsrt}
	\bibliography{ref.bib}{}

\end{document}                                 
